# sync map

## sync.map原理：
		
使用read和dirty两个map来进行读写分离，通过空间换时间的方式，降低锁时间来提高效率。
		
通过 read 和 dirty 两个字段将读写分离，读的数据存在只读字段 read 上，将最新写入的数据则存在 dirty 字段上

1. 读取时会先查询read，不存在再查询dirty，写入时则只写入dirty
2. 读取read并不需要加锁，而读或写dirty都需要加锁
3. 另外有 misses 字段来统计read被穿透的次数（被穿透指需要读 dirty 的情况），超过一定次数则将dirty数据同步到 read 上
4. 对于删除数据则直接通过标记来延迟删除

## 使用场景优点：
适合读多写少的场景

缺点：

写多的场景，会导致read map缓存失效，需要加锁，冲突变多，性能急剧下降

sync.map特点：

sync.map 是线程安全的，读取，插入，删除也都保持着常数级的时间复杂度。

原因：

Go语言原生map并不是线程安全的，对它进行并发读写操作的时候，需要加锁。
原生map并发读取缺点：
		
解决并发读写 map 的思路是锁，但是效率低。
所以引入：sync.map
sync.map则是一种并发安全的map，在Go1.9引入。