# 浏览器输入URL后发生了什么

这是我面试的时候最喜欢问的问题之一。

## 摘要
1. DNS解析
2. 建立TCP连接
3. 发生HTTP请求
4. 服务器处理请求
5. 返回响应结果
6. 关闭TCP连接
7. 浏览器解析HTML
8. 浏览器布局渲染

### 1. 浏览器进行地址解析，域名补全；DNS域名解析
例如默认端口80， 协议http，主机www等

DNS解析过程：

1. 浏览器检查自身缓存中是否有解析过这个域名，如果命中则解析结束，更新缓存TTL。
2. 浏览器检查系统缓存中有没有该域名对应的IP地址，比如hosts。
3. 上面两个步骤都没有，则请求本地域名服务器（LDNS）来解析，这台服务器一般会缓存大部分域名的解析结果
4. 如果LDNS也没有命中，则请求Root Server服务器进行解析。
5. 根域名服务器返回给LDNS一个所查询域的主域名服务器（gTLD Server，国际顶尖域名服务器，如.com .cn .org等）地址
6. LDNS再发送解析请求给gTLD
7. gTLD查找并返回这个域名对应的Name Server的地址，这个Name Server就是网站注册的域名服务器
8. Name Server根据映射关系表找到目标ip，返回给LDNS
9. LDNS缓存这个域名和对应的IP
10. LDNS把解析结果返回给浏览器，浏览器缓存解析结果，解析结束

![](/uploads/upload_7533f83f543c00b06d950850f0d72844.png)


### 2. 通过IP寻址和ARP路由映射找到对应的服务器，三次握手建立TCP连接

![](/uploads/upload_230f67693cf130b5cb8cbb12d4c7aab0.png)

- 第一次握手：客户端将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给服务器端，客户端进入SYN_SENT状态，等待服务器端确认。

- 第二次握手：服务器端收到数据包后由标志位SYN=1知道客户端请求建立连接，服务器端将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给客户端以确认连接请求，服务器端进入SYN_RCVD状态。

- 第三次握手：客户端收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给服务器端，服务器端检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，客户端和服务器端进入ESTABLISHED状态，完成三次握手，随后客户端与服务器端之间可以开始传输数据了。

### 3. 发送HTTP请求，等待响应

**HTTP请求方法**

1. GET
    发送请求来获取服务器上的资源
2. HEAD
    HEAD方法和GET方法的行为很类似，但是服务器在响应中只返回首部，不会返回实体的主体部分。这就允许客户端在未获取实际资源的情况下，对资源的首部进行检查。

    使用HEAD方法有以下优点：

    - 在不获取资源的情况下了解资源的情况（比如：判断其类型）；
    - 通过查看响应的状态码，看看某个对象是否存在；
    - 通过查看首部，测试资源是否被修改了
3. PUT
    与GET从服务器读取文档相反，PUT方法会向服务器写入文档。
4. POST
    POST方法期初是用来向服务器输入数据的，实际上，通常会用它来支持HTML的表单。表单中填好的数据通常会被送给服务器，然后由服务器将其发送到它要去的地方。
5. TRACE
    回显服务器收到的请求，主要用于测试或诊断。一般禁用，防止被恶意攻击或盗取
6. OPTIONS
    返回服务器针对特定资源所支持的HTTP请求方法，也可以利用向web服务器发送‘*’的请求来测试服务器的功能性
7. DELETE
    请求服务器删除Request-URL所标识的资源
8. PATCH   
    只更新服务器上的某些字段
    
**GET 和 POST 区别**

1. GET请求的数据是放在HTTP包头中的，也就是URL之后，通常是像下面这样定义格式的：login.action?name=hyddd&password=idontknow&verify=%E4%BD%E5%A5%BD 其中，以?来分隔URL和数据；以&来分隔参数；如果数据是英文或数字，原样发送；如果数据是中文或其它字符，则进行BASE64编码。

    而Post是把提交的数据放在HTTP正文中的。

2. GET提交的数据比较少，最多1024B，因为GET数据是附在URL之后的，而URL则会受到不同环境的限制的，比如说IE对其限制为2K+35，
    
    而POST可以传送更多的数据（理论上是没有限制的，但一般也会受不同的环境，如浏览器、操作系统、服务器处理能力等限制，IIS4可支持80KB，IIS5可支持100KB）。

3. Post的安全性要比Get高，因为Get时，参数数据是明文传输的，参数直接暴露在url中，所以不能用来传递敏感信息。而且使用GET的话，还可能造成Cross-site request forgery攻击。而POST数据则可以加密的，但GET的速度可能会快些。
        
4. get请求只能进行url编码，而post支持多种编码方式；get请求会浏览器主动cache，而post支持多种编码方式；get请求参数会被完整保留在浏览历史记录里，而post中的参数不会被保留。


5. GET和POST本质上就是TCP链接，并无差别。但是由于HTTP的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同。

6. GET产生一个TCP数据包；POST产生两个TCP数据包。对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。当然GET也可以发body。

### 4. 服务器处理请求
### 5. 返回响应结果
### 6. 关闭TCP连接 4次挥手

![](/uploads/upload_045fe5745aff665c20cd8d965a796527.png)

中断连接端可以是客户端，也可以是服务器端。

- 第一次挥手：客户端发送一个FIN=M，用来关闭客户端到服务器端的数据传送，客户端进入FIN_WAIT_1状态。意思是说"我客户端没有数据要发给你了"，但是如果你服务器端还有数据没有发送完成，则不必急着关闭连接，可以继续发送数据。

- 第二次挥手：服务器端收到FIN后，先发送ack=M+1，告诉客户端，你的请求我收到了，但是我还没准备好，请继续你等我的消息。这个时候客户端就进入FIN_WAIT_2 状态，继续等待服务器端的FIN报文。

- 第三次挥手：当服务器端确定数据已发送完成，则向客户端发送FIN=N报文，告诉客户端，好了，我这边数据发完了，准备好关闭连接了。服务器端进入LAST_ACK状态。

- 第四次挥手：客户端收到FIN=N报文后，就知道可以关闭连接了，但是他还是不相信网络，怕服务器端不知道要关闭，所以发送ack=N+1后进入TIME_WAIT状态，如果Server端没有收到ACK则可以重传。服务器端收到ACK后，就知道可以断开连接了。客户端等待了2MSL后依然没有收到回复，则证明服务器端已正常关闭，那好，我客户端也可以关闭连接了。最终完成了四次握手。

### 7. 浏览器解析HTML

### 8. 浏览器布局渲染

html解析->外部样式、脚本加载->外部样式执行->外部脚本执行->html继续解析->dom树构建完成->加载图片->页面加载完成