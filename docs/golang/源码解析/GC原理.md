# GC原理

垃圾回收（Garbage Collection），是后台运行的一个守护进程，它的作用是在监控各个对象的状态，识别并且丢弃不再使用的对象来释放和重用资源。

现在的go使用的回收机制是三色标记配合写屏障和辅助GC来完成的。

以前用的是标记清除法。

**标记-清除法（mark and sweep）**

1. 标记，先STW（stop the word）暂停整个程序的全部运行线程，将被引用的对象打上标记。
2. 清除没有标记的对象（回收内存资源），然后恢复运行线程。

缺点：通过STW保证GC期间标记的对象状态不变，但是整个过程程序要暂停，出现卡顿。

**三色标记法**

1. 初始状态所有的对象都是白色的。
2. 从root出发扫描所有的根对象，将他们引用的对象标记为灰色。
3. 分析灰色对象是否有引用其他对象，如果没有，则将该灰色对象标记为黑色，如果有引用对象，则把它标记成黑色的同时，把引用对象标记成灰色。
4. 重复步骤3，直到灰色队列为空，此时白色对象即位垃圾需要回收。

## GC流程

1. MARK
    1. mark prepare: 初始化GC任务，包括开启写屏障（write barrier） 和 辅助GC（mutator assist），统计root对象的任务数量等，需要STW。
    2. GC drains：扫描所有的root对象，包括全局指针和groutine栈上的指针（扫描对应G时需要暂停该G），将其标记为灰色，并循环处理灰色对象，直到灰色队列为空。该过程在后台并行运行。
2. Mark Termination：完成标记工作，重新扫描（re-scan）全局指针和栈，因为mark和用户程序时并行的，所以在mark过程中可能会有新的对象分配和指针赋值，这个时候需要写屏障记录下来，re-scan再检查一下，这个过程也会STW
3. Sweep：按照标记结果回收所有白色对象，这个过程也在后台并行运行。
4. Sweep Termination：对未清扫的span进行清扫，只有上一轮GC的清扫工作完成才可以开始新一轮的GC。

## 写屏障

在每一轮GC开始时会初始化一个叫“屏障”的东西，然后由它记录第一次scan时各个对象的状态，以便和第二次re-scan进行对比，引用状态变化的对象被标记为灰色以防丢失。将屏障前后状态未变化的对象继续处理。

## 辅助GC

如果发现扫描后回收的速度跟不上分配的速度，它依然会把用户逻辑暂停（STW），用户逻辑暂停后聚不会有新对象出现，同时会把用户线程抢过来加入到垃圾回收里，加快垃圾回收速度。这样以来原来的并发就又出现了STW，要不然扫描和回收没完没了。所有这种机制叫做辅助GC。

## GC出发条件

1. 超过内存大小阈值
2. 达到定时时间
3. 手动触发GC

## GC优化

1. 减少对象的分配，合理重复利用。
2. 避免string和[]byte转换：两者相互转换时，底层数据结构发生复制，导致GC效率变低。
3. 减少使用+来连接string：golang里string是一个基础的只读类型，对它的每一个操作都会创建一个新的string。
   如果是少量小文本用+没有问题
   如果是大量小文本建议使用string.Join
   如果是大量大文本建议使用bytes.Buffer