# 设计思路

好的性能是设计出来的，不是调优出来的

## 范式和反范式设计

### 范式设计
```json
{
    _id: ObjectID(xxxxx),
    rid: xxxxx,
    es: [
        ObjectID(1),
        ObjectID(2),
        ObjectID(3)
    ]
}
```

对于经常修改事件有优势，直接根据事件ID修改即可，但是查询时（比如按事件操作员、结果查询）需要连表查询效果就不理想了。

### 反范式设计
```json
{
    _id: ObjectID(xxxxx),
    rid: xxxxx,
    es: [
        {
            _id: ObjectID(1),
            o: xiezhenjia,
            r: reject
        },
        {
            _id: ObjectID(2),
            o: wuhuan,
            r: accept
        },
        {
            _id: ObjectID(3),
            o: yinghui,
            r: reject
        }
    ]
}
```

考虑到审核只添加事件，基本不修改事件，而且查询时需要完整的信息，所以选择反范式设计比较合理。

## _id

文档中的_id键推荐使用默认值，禁止向_id中保存自定义的值。

MongoDB文档中都会有一个“_id”键，默认是个ObjectID对象（标识符中包含时间戳、机器ID、进程ID和计数器）。MongoDB在指定_id与不指定_id插入时 速度相差很大，指定_id会减慢插入的速率。

好处：

时间范围查询
按时间文档排序，一般逆序，新文档排在前面
写入速度快，主索引b+树顺序写入快

## 使用短字段名

与关系型数据库不同，MongoDB集合中的每一个文档都需要存储字段名，长字段名会需要更多的存储空间。

## 合理的索引

索引可以提高更新、删除、修改、查询操作的效率，按需求合理创建索引

每个索引都需要占用空间，插入时需要维护，所以不宜建立过多的索引。

充分利用复合索引，最左前缀原则

尽量选择细粒度的索引，比如rid

粗力度的有status、result等


## TTL 索引（time-to-live index，具有生命周期的索引），使用TTL索引可以将超时时间的文档老化，一个文档到达老化的程度之后就会被删除。

创建TTL的索引必须是日期类型。TTL索引是一种单字段索引，不能是复合索引。TTL删除文档后台线程每60s移除失效文档。不支持定长集合。

比如 群聊天、昵称等历史审核记录，半年一年后保留的意义不大，可以使用TTL索引使文档老化删除。

## count

如果文档数量很多的话，比如超过10万，返回10万+就好了，没必要继续count，按条件count很慢的。

## 查询中的某些$操作符可能会导致性能低下，如操作符可能会导致性能低下，如$ne，$，not，$exists，$nin，$or尽量在业务中不要使用。

a) $exist:因为松散的文档结构导致查询必须遍历每一个文档；
b) $ne:如果当取反的值为大多数，则会扫描整个索引；
c) $not:可能会导致查询优化器不知道应当使用哪个索引，所以会经常退化为全表扫描；
d) $nin:全表扫描；
e) `\$`有多个条件就会查询多少次，最后合并结果集，应该考虑装换为or:有多个条件就会查询多少次，最后合并结果集，应该考虑装换为$in。

## 统计预处理、实时统计

## 分片

按rid hash分片，理由是经常使用rid来查询