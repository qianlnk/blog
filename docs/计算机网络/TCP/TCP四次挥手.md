
# TCP四次挥手

可以合并成3次, 如果服务器有数据要发送, 为了避免客户端重发 FIN 包, 所以服务器尽快返回 ACK; 如果服务器没有要发送的数据, 那么 FIN+ACK 的合并发送方式就会是3次握手.

![](/uploads/upload_216aec07e462817b2476e1fb5c9005c3.png)

![](/uploads/upload_eff45568ca1719cd3a23d03f7670fdd9.png)

- 第一次挥手：客户端发送一个FIN=M，用来关闭客户端到服务器端的数据传送，客户端进入FIN_WAIT_1状态。意思是说"我客户端没有数据要发给你了"，但是如果你服务器端还有数据没有发送完成，则不必急着关闭连接，可以继续发送数据。

- 第二次挥手：服务器端收到FIN后，先发送ack=M+1，告诉客户端，你的请求我收到了，但是我还没准备好，请继续你等我的消息。这个时候客户端就进入FIN_WAIT_2 状态，继续等待服务器端的FIN报文。

- 第三次挥手：当服务器端确定数据已发送完成，则向客户端发送FIN=N报文，告诉客户端，好了，我这边数据发完了，准备好关闭连接了。服务器端进入LAST_ACK状态。

- 第四次挥手：客户端收到FIN=N报文后，就知道可以关闭连接了，但是他还是不相信网络，怕服务器端不知道要关闭，所以发送ack=N+1后进入TIME_WAIT状态，如果Server端没有收到ACK则可以重传。服务器端收到ACK后，就知道可以断开连接了。客户端等待了2MSL后依然没有收到回复，则证明服务器端已正常关闭，那好，我客户端也可以关闭连接了。最终完成了四次握手。

**同时主动关闭的情况**

![](/uploads/upload_5fffb2ca139c6a54ceb5da023cc6458c.png)

## 为什么是四次挥手

回顾下四次挥手中发送FIN包过程就可以理解。

1. 关闭连接时，客户端没有数据要发送了，发送FIN包，但还能接收数据
2. 服务端收到客户端FIN后发送ACK，而服务端可能还有数据需要处理和发送，等服务端没有数据要处理时才发送FIN报文给客户端表示同意关闭连接。

服务端通常需要等待完成数据的发送和处理，所以服务端的 ACK 和 FIN 一般都 会分开发送，从而导致比三次握手多了一次。

## 为什么TIME_WAIT等待时间是2MSL

网络中可能还存在发送方的数据包，当这些发送方的数据包被接收方处理后又会向对方发送响应，所以一来一回需要等待 2 倍的时间。

## 为什么需要TIME_WAIT状态

1. **防止旧连接的数据包**

![](/uploads/upload_5f7faaded375a7f9b5766a3805ce728d.png)

如果在关闭连接之前发送的黄色的数据包被网络延迟了，而关闭连接没有TIME_WAIT，这是如果有相同端口的TCP连接被复用，新的连接很有可能会正常接收这个被延迟的数据包，就导致数据错乱了。

2. **保证连接的正常关闭**

![](/uploads/upload_bb261204914fcdb94d4a3e8f3ed07c4f.png)

 如上图红色框框客户端四次挥手的最后一个 ACK 报文如果在网络中被丢失了，此时如果客户端 TIME-WAIT 过短或没有，则就直接进入了 CLOSE 状态了，那么服务端则会一直处在 LASE-ACK 状态。
    
    当客户端发起建立连接的 SYN 请求报文后，服务端会发送 RST 报文给客户端，连接建立的过程就会被终止。
    
    
## TIME_WAIT过多的危害
- 内存资源占用
- 端口资源占用，端口资源也是有限的，一般可以开启的端口为 32768～61000，也可以通过如下参数设置指定
    ```
    net.ipv4.ip_local_port_range
    ```

## TIME_WAIT优化

- 打开 net.ipv4.tcp_tw_reuse 和 net.ipv4.tcp_timestamps 选项

    ```
    net.ipv4.tcp_tw_reuse = 1
    ```
    ```
    net.ipv4.tcp_timestamps=1（默认即为 1）
    ```
    
    复用处于 TIME_WAIT 的 socket 为新的连接所用

    *注意： 当客户端与服务端主机时间不同步时，客户端的发送的消息会被直接拒绝掉。*
    
- net.ipv4.tcp_max_tw_buckets

    当系统中处于 TIME_WAIT 的连接一旦超过这个值时，系统就会将所有的 TIME_WAIT 连接状态重置。

   *注意：这个方法过于暴力，而且治标不治本，带来的问题远比解决的问题多，不推荐使用。*

- 程序中使用 SO_LINGER ，应用强制使用 RST 关闭。

    我们可以通过设置 socket 选项，来设置调用 close 关闭连接行为。
    
    ```
    struct linger so_linger;
    so_linger.l_onoff = 1;
    so_linger.l_linger = 0;
    setsockopt(s, SOL_SOCKET, SO_LINGER, &so_linger,sizeof(so_linger));
    ```
    
    如果l_onoff为非 0， 且l_linger值为 0，那么调用close后，会立该发送一个RST标志给对端，该 TCP 连接将跳过四次挥手，也就跳过了TIME_WAIT状态，直接关闭。
    
    但这为跨越TIME_WAIT状态提供了一个可能，不过是一个非常危险的行为，不值得提倡。