# AOF重写

## AOF重写的必要性

AOF比RDB文件更大，并且在存储命令的过程中增长更快，为了压缩AOF的持久化文件，Redis提供了重写机制以此来实现控制AOF文件的增长。

AOF重写实现的理论基础是这样的：

- 执行set hello world 50次 

- 最后执行一次 set hello china

- 最终对于AOF文件而言前面50次都是无意义的，AOF重写就是将key只保存最后的状态。

## 重写期间的数据一致性问题

子进程在进行 AOF 重写期间， 主进程还需要继续处理命令， 而新的命令可能对现有的数据进行修改， 会出现数据库的数据和重写后的 AOF 文件中的数据不一致。

因此Redis 增加了一个 AOF 重写缓存， 这个缓存在 fork 出子进程之后开始启用， Redis 主进程在接到新的写命令之后， 除了会将这个写命令的协议内容追加到现有的 AOF 文件之外， 还会追加到这个缓存中。

![](/uploads/upload_24814fbf42aa143351254e6003ed9264.png)

## AOF文件覆盖

当子进程完成 AOF 重写之后向父进程发送一个完成信号， 父进程在接到完成信号之后会调用信号处理函数，完成以下工作：

- 将 AOF 重写缓存中的内容全部写入到新 AOF 文件中

- 对新的 AOF 文件进行改名，覆盖原有的 AOF 文件

## AOF重写的阻塞性

整个 AOF 后台重写过程中只有最后写入缓存和改名操作会造成主进程阻塞， 在其他时候AOF 后台重写都不会对主进程造成阻塞， 将 AOF 重写对性能造成的影响降到了最低。

## AOF重写的触发条件

- AOF 重写可以由用户通过调用 BGREWRITEAOF 手动触发。

- 服务器在 AOF 功能开启的情况下，会维持以下三个变量：
    
    - 当前 AOF 文件大小 

    - 最后一次 重写之后， AOF 文件大小的变量 

    - AOF文件大小增长百分比

    每次当 serverCron 函数执行时， 它都会检查以下条件是否全部满足， 如果是的话， 就会触发自动的 AOF 重写：

    - 没有 BGSAVE 命令在进行 防止于RDB的冲突

    - 没有 BGREWRITEAOF 在进行 防止和手动AOF冲突

    - 当前 AOF 文件大小至少大于设定值 基本要求 太小没意义

    - 当前 AOF 文件大小和最后一次 AOF 重写后的大小之间的比率大于等于指定的增长百分比
