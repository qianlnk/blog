# HTTPS详细解析

一次完整的HTTPS加密通讯的过程如下：

![](/uploads/upload_e592419f4314c1b9182186b56685b09a.png)

发送端：
1. 利用商定的随机数和摘要算法计算明文的MAC（Message Authentication Code，消息认证码），常见的消息摘要算法有MD5、SHA1、SHA256等。

2. 将明文用商定的加密算法进行加密，得出密文。目前主流的加密方法有两种：一种是利用商定的对称密钥进行对称加密，对称加密算法在安全性上不如非对称加密算法，但是对称加密算法的计算效率高，因此一般用于传输机密性等级不高且量大的内容，常见的对称加密算法有RC4、DES、3DES、AES等；另一种是使用对方的公钥进行非对称加密，与对称机密算法相反，该算法安全性高但是计算效率低，因此一般用于加密机密性等级高的内容，常见的非对称加密算法有RSA、Elgamal、椭圆曲线加密算法等。

3. 用私钥将MAC码进行加密，得到了一个数字签名，使得消息不可否认。

4. 将密文和数字签名进行拼接，然后发送给接收端。

接收端：

5. 拆分消息得到密文和数字签名，利用商定的加密算法及其对应的密钥进行解密，得到明文。

6. 用发送端的公钥对数字签名进行解密，得到MAC码。

7. 利用商定的随机数和摘要算法计算明文的MAC码，并与收到的MAC进行比较，若相等则说明得到了正确的明文，若两个MAC值不等，则重新请求数据。

## SSL/TLS协议

SSL（Server Socket Layer，安全套接字层），协议位于OSI七层模型中的表示层的可靠的面向连接的协议，SSL通过互相认证、使用摘要算法确保完整性和使用加密算法确保私密性，使得客户端和服务端实现了安全的通讯。主要由SSL记录协议和SSL握手协议组成，目前SSL的最新版本是1996年发布的SSL3.0，虽然该协议在2015年被RFC 7568列为不安全协议而不建议使用，但是有部分服务器仍在使用。

TLS（Transport Layer Security, 传输层安全），协议是在SSL3.0的基础上改进的协议，是SSL3.0的后续版本，并在1999年发布了第一个版本TLS1.0。作为SSL的升级版，TLS协议与SSL协议具有相同的目的：解决浏览器与服务器通讯中的认证、保密性和完整性的安全问题。TLS协议也可以分为两个部分：记录协议（Record Protocol）和握手协议（Handshake Protocol）。目前TLS的最新版本是2018年发布的TLS1.3，但是目前使用最广泛的还是2008年发布的TLS1.2

## TLS握手协议（4次握手）

以TLS1.2为例

![](/uploads/upload_0493556eeca94becde493e19d0c9d245.png)


- 第一次握手
  
    客户端向服务端发送client hello消息，消息以明文的形式传输，信息包括：客户端支持的协议版本、加密套件（认证算法、密钥交换算法、对称加密算法、信息摘要算法）、压缩算法、客户端生成的一个随机数R1，和扩展字段等。    

- 第二次握手
  
    1. 服务端发送server hello消息进行响应，消息也是以明文形式传输，消息包括：确认使用协议的版本号、服务端生成的一个随机数R2，确认使用的加密套件、确认使用的压缩算法。
    2. 在发完server hello后，马上会将自己的Certificate（公钥证书）发送给客户端。
    3. 在选用了DH算法的情况下，服务器需要将DH参数发送给客户端，若选择了RSA算法则不需要发送Server Key Exchange。
    4. 在对于安全性要求较高的场景中，服务器可要对客户端的身份进行认证，因此发起了对客户端公钥证书的请求，一般情况下浏览器都会内置一对独一无二的公私钥。
    5. 由于第二次握手中包含一些可选选项，因此需要服务器发送一个Server Hello Done的消息，用来通知客户端Server Hello过程结束。

- **证书验证**
    
    在客户端收到Server Hello Done之后并没有马上进行第三次握手，而是先对服务器传来的证书进行验证，一般会验证证书是否在有效期内，随后根据CRL或者OCSP查询证书是否有效，最后根据证书链从根CA开始验证直到网站证书，以确保证书的真实性。在这个过程中若出现了验证不通过的结果，则抛出相应的错误；若验证通过，就再生成一个随机数Pre-master，并用服务器公钥进行加密，生成PreMaster Key。

- 第三次握手

1. Client Key Exchange就是客户端将PreMaster Key发送给服务器，服务器则会用自己的私钥解密得出Pre-master。到这里客户端和服务器都拥有了三个随机数R1、R2和Pre-master，两边再用相同的算法和这三个随机数生成一个密钥，用于握手结束后传输数据的对称加密。

2. Change Cipher Spec是客户端向服务器通知，后面发送的消息都会使用协商出来的密钥进行加密。

3. Encrypted Handshake Message是客户端向服务发送握手数据加密信息，该信息是客户端将前面的握手消息利用协商好的摘要算法生成摘要，再用协商好的密钥对摘要进行加密而的出来的，最后将加密信息发送给服务器，这是客户端发出的第一条加密信息。而服务器也会用协商好的密钥进行解密，若能成功解密则说明协商出来的密钥是一致的。

4. Certificate是在第二次握手的第4步有进行的情况下，即服务器有向客户端请求证书的情况才会有的，这一步是客户端向服务器发送客户端的证书，而服务器收到证书后也会对证书进行相同的验证。

- 第四次握手

1. Change Cipher Spec是服务器向客户端通知，后面发送的消息都会使用协商出来的密钥进行加密。

2. Encrypted Handshake Message与第三次握手类似，是服务器发给客户端的用来确定协商的密钥是一致的，也是一条Server Finish消息。

**TLS四次握手的过程是相对复杂的，要消耗一定的资源，若每次建立HTTPS连接都要进行TLS四次握手的话将会消耗较多的资源，导致效率较低。**

## 会话缓存机制

session ID和session ticket。其中session ID是协议中标准字段，所以基本所有服务器都支持，session ID和协商的通讯信息会保存在服务器端；而session ticket是一个扩展字段，需要服务器和客户端都支持，服务器会将协商的通讯信息加密后发送给客户端保存，密钥只有服务器直到，这就占用了较少的服务器资源。

![](/uploads/upload_86126353105060fa35a297bcf92f096a.png)

这里的Client Hello多了Session ID（或Session Ticket）参数。且客户端在发送完最后一个握手数据包后就直接开始向服务器发送应用数据。

## TLS记录协议

![](/uploads/upload_2665d142556860cd51ddabe53cc5ad2f.png)

TLS记录协议是在客户端和服务器发送交互消息的时候使用的一个协议。根据RFC5246的规定，TLS记录协议是一个分层协议，主要负责消息压缩、加密和数据的认证。

对于一条交互消息，首先会将消息分割成若干个片段，每个片段不多于2^14字节（即16kb），然后对每一个片段分别使用协商好的压缩算法进行压缩，得到对应的压缩片段。接下来计算每个压缩片段的MAC值，并MAC值中加入序号后连接在压缩片段后面。连接完成后则用协商好的对称加密算法和密钥进行加密得到密文。最后在密文前面加上由数据类型、协议版本号和压缩后长度组成的报头，组成最终的报文数据，并将报文数据传送给TCP层进行打包发送。