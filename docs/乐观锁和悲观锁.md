# 乐观锁和悲观锁

- **乐观锁（ Optimistic Locking）**：顾名思义，对加锁持有一种乐观的态度，即先进行业务操作，不到最后一步不进行加锁，"乐观"的认为加锁一定会成功的，在最后一步更新数据的时候再进行加锁。
- **悲观锁（Pessimistic Lock）**：正如其名字一样，悲观锁对数据加锁持有一种悲观的态度。因此，在整个数据处理过程中，将数据处于锁定状态。悲观锁的实现，往往依靠数据库提供的锁机制（也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系统不会修改数据）。

## 使用场景

**乐观锁：**

　　比较适合读取操作比较频繁的场景，如果出现大量的写入操作，数据发生冲突的可能性就会增大，为了保证数据的一致性，应用层需要不断的重新获取数据，这样会增加大量的查询操作，降低了系统的吞吐量。

**悲观锁：**

　　比较适合写入操作比较频繁的场景，如果出现大量的读取操作，每次读取的时候都会进行加锁，这样会增加大量的锁的开销，降低了系统的吞吐量。
　　
　　**读取频繁使用乐观锁，写入频繁使用悲观锁。乐观锁不能解决脏读的问题。**
　　
## 实现方式

**乐观锁：**
程序自己实现，比如数据版本控制、时间戳等 修改时判断版本是不是当前版本，不是则报错又用户自己去处理。

**悲观锁**
依靠数据库的底层锁实现。

- 共享锁

    在需要锁定时加上`lock in share mode`即可。
    
    如：
    
    ```sql
    begin;
    update table1 set name='xiezhenjia' where id=1 lock in share mode;
    commit;
    ```
    
    此时其他事务可以执行`select`查询语句，但也要加上共享锁，不能执行`insert`、`update`、`delete`语句，因为这些操作mysql会自动加上排他锁。

- 排他锁
    在需要锁定时加上`for update`即可。
    
    如：
    ```sql
    begin;
    select name from table1 where id = 1 for update;
    
    ```
    
    对于Innodb引擎语句后面加上for update表示把此行数据锁定，MyISAM则是锁定整个表。